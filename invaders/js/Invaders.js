// Generated by CoffeeScript 1.3.1
(function() {
  var Invader, Invaders, Util,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  this.WIDTH = 620;

  this.HEIGHT = 480;

  this.BACKGROUND_COLOR = 0xFFFFFF;

  this.VIEW_ANGLE = 45;

  this.NEAR = 1;

  this.FAR = 10000;

  this.CAMERA_DISTANCE = 300;

  this.ASPECT = this.WIDTH / this.HEIGHT;

  this.INVADER_SIZE = 5;

  this.CUBE_SIZE = 20;

  this.GRAVITY = -0.5;

  this.COLOR_POOL = [0x333333, 0x66CCFF, 0xCC0000, 0x66CC00, 0xFF6600];

  Invaders = (function() {

    Invaders.name = 'Invaders';

    function Invaders(container) {
      this.cleanupHandler = __bind(this.cleanupHandler, this);

      this._keyDownHandler = __bind(this._keyDownHandler, this);

      this._animate = __bind(this._animate, this);
      this.container = container;
      this._init();
      this._animate();
      return this;
    }

    Invaders.prototype._init = function() {
      this._createScene();
      this._addLights();
      this._addRandomInvader();
      return this._setupEvents();
    };

    Invaders.prototype._setupEvents = function() {
      return window.addEventListener("keydown", this._keyDownHandler);
    };

    Invaders.prototype._animate = function() {
      var timer;
      requestAnimationFrame(this._animate);
      timer = 0.001 * Date.now();
      this._updateCameraAnimation(timer);
      return this._updateInvadersAnimations(timer);
    };

    Invaders.prototype._updateCameraAnimation = function(timer) {
      if (this.camera == null) {
        return;
      }
      this.camera.position.x = Math.sin(timer) * CAMERA_DISTANCE;
      this.camera.position.z = Math.cos(timer) * CAMERA_DISTANCE;
      this.camera.lookAt(new THREE.Vector3(0, 0, 0));
      return this.renderer.render(this.scene, this.camera);
    };

    Invaders.prototype._updateInvadersAnimations = function(timer) {
      var invader, _i, _len, _ref, _results;
      if (this.invaders == null) {
        return;
      }
      _ref = this.invaders;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        invader = _ref[_i];
        if (invader != null) {
          _results.push(invader.updateAnimation(timer));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Invaders.prototype._createScene = function() {
      this.scene = new THREE.Scene();
      this.renderer = new THREE.WebGLRenderer();
      this.renderer.setSize(WIDTH, HEIGHT);
      this.renderer.setClearColorHex(BACKGROUND_COLOR, 1.0);
      this.camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
      this.camera.position.x = 0;
      this.camera.position.y = 0;
      this.camera.position.z = CAMERA_DISTANCE;
      this.scene.add(this.camera);
      return this.container.appendChild(this.renderer.domElement);
    };

    Invaders.prototype._addLights = function() {
      var light1, light2;
      light1 = new THREE.PointLight(0xffffff);
      light1.position.set(WIDTH / 2, HEIGHT / 2, 400);
      this.scene.add(light1);
      light2 = new THREE.PointLight(0xffffff);
      light2.position.set(-WIDTH / 2, HEIGHT / 2, -400);
      return this.scene.add(light2);
    };

    Invaders.prototype._addRandomInvader = function() {
      var invader;
      this.invaders || (this.invaders = []);
      invader = new Invader(Math.random() * 32768, this.cleanupHandler);
      invader.position.set(0, 0, 0);
      this.scene.add(invader);
      return this.invaders.push(invader);
    };

    Invaders.prototype._destroyInvaders = function() {
      var invader, _i, _len, _ref;
      if (this.invaders == null) {
        return;
      }
      _ref = this.invaders;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        invader = _ref[_i];
        invader.destroy();
      }
      return this._addRandomInvader();
    };

    Invaders.prototype._keyDownHandler = function(event) {
      if (event.keyCode === 32) {
        return this._destroyInvaders();
      }
    };

    Invaders.prototype.cleanupHandler = function(invader) {
      var i, _i, _ref;
      for (i = _i = 0, _ref = this.invaders.length; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (this.invaders[i] === invader) {
          this.invaders.splice(i, 1);
          this.scene.remove(invader);
          return;
        }
      }
    };

    return Invaders;

  })();

  Invader = (function(_super) {

    __extends(Invader, _super);

    Invader.name = 'Invader';

    function Invader(seed, cleanupCallback) {
      Invader.__super__.constructor.call(this);
      this.seed = seed;
      this.cleanupCallback = cleanupCallback;
      this._init();
      return this;
    }

    Invader.prototype.updateAnimation = function(timer) {
      var cleanup, cube, _i, _len, _ref;
      cleanup = false;
      _ref = this.cubes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        cube = _ref[_i];
        cube.vy += cube.gravity;
        cube.position.x += cube.vx;
        cube.rotation.x += cube.rvx;
        cube.position.y += cube.vy;
        cube.rotation.y += cube.rvy;
        cube.position.z += cube.vz;
        cube.rotation.z += cube.rvz;
        cleanup || (cleanup = cube.position.y < -6 * HEIGHT);
      }
      if (cleanup) {
        return this._cleanupDestroy();
      }
    };

    Invader.prototype.destroy = function() {
      var cube, _i, _len, _ref, _results;
      _ref = this.cubes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        cube = _ref[_i];
        cube.vx = Math.random() * 20 - 10;
        cube.rvx = Math.random() * Math.PI;
        cube.vy = Math.random() * 20;
        cube.rvy = Math.random() * Math.PI;
        cube.vz = Math.random() * 20 - 10;
        cube.rvz = Math.random() * Math.PI;
        _results.push(cube.gravity = GRAVITY);
      }
      return _results;
    };

    Invader.prototype._init = function() {
      this._createMaterial();
      return this._build();
    };

    Invader.prototype._build = function() {
      var configuration, cube, i, offset, row, totalCubes, _i, _results;
      configuration = this._generateConfiguration(this.seed);
      totalCubes = configuration.length;
      row = 0;
      offset = INVADER_SIZE * CUBE_SIZE * 0.5;
      _results = [];
      for (i = _i = 0; 0 <= totalCubes ? _i <= totalCubes : _i >= totalCubes; i = 0 <= totalCubes ? ++_i : --_i) {
        if (i % INVADER_SIZE === 0 && i > 0) {
          row++;
        }
        if (configuration[i] === "1") {
          cube = this._generateCube(CUBE_SIZE);
          cube.position.x = (i % INVADER_SIZE) * CUBE_SIZE - offset;
          cube.position.y = row * CUBE_SIZE - offset;
          cube.vx = cube.vy = cube.vz = cube.rvx = cube.rvy = cube.rvz = 0;
          cube.gravity = 0;
          _results.push(this._addCube(cube));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Invader.prototype._cleanupDestroy = function() {
      this.cubes.length = 0;
      if (this.cleanupCallback != null) {
        return this.cleanupCallback(this);
      }
    };

    Invader.prototype._addCube = function(cube) {
      this.cubes || (this.cubes = []);
      this.cubes.push(cube);
      return this.add(cube);
    };

    Invader.prototype._generateCube = function(size) {
      var cube;
      return cube = new THREE.Mesh(new THREE.CubeGeometry(size, size, size), this.material);
    };

    Invader.prototype._generateConfiguration = function(seed) {
      var binarySeed, configuration, i, row, seedPosition, totalCubes, _i;
      configuration = [];
      binarySeed = Util.decimal2BinaryString(seed);
      totalCubes = INVADER_SIZE * INVADER_SIZE;
      seedPosition = 0;
      row = 0;
      for (i = _i = 0; 0 <= totalCubes ? _i <= totalCubes : _i >= totalCubes; i = 0 <= totalCubes ? ++_i : --_i) {
        if (i % INVADER_SIZE === 0 && i > 0) {
          row++;
        }
        if (i % INVADER_SIZE < Math.ceil(INVADER_SIZE / 2)) {
          configuration[i] = binarySeed[seedPosition++];
        } else {
          configuration[i] = configuration[(row * INVADER_SIZE) + (INVADER_SIZE - 1 - i % INVADER_SIZE)];
        }
      }
      return configuration;
    };

    Invader.prototype._createMaterial = function() {
      return this.material = new THREE.MeshPhongMaterial({
        color: COLOR_POOL[Math.floor(Math.random() * COLOR_POOL.length)],
        shininess: 100.0,
        specular: 0xFFFFFF
      });
    };

    return Invader;

  })(THREE.Object3D);

  Util = (function() {

    Util.name = 'Util';

    function Util() {}

    Util.decimal2BinaryString = function(number, precision) {
      var out;
      out = "";
      while (number > 0) {
        out = number % 2 > 0 ? "1" + out : "0" + out;
        number = Math.floor(number / 2);
      }
      while (out.length < precision - 1) {
        out = "0" + out;
      }
      return out;
    };

    return Util;

  })();

  this.startInvaders = function(container) {
    if (container == null) {
      container = document.createElement('div');
      document.body.appendChild(container);
    }
    return new Invaders(container);
  };

}).call(this);
